and (8.5b)where nj and kj represent the individual bits of the number. For example, if N  8, then we need only three bits (j  0 to 2) to represent nand k, since they can take on values of only 0 to 7. Thus n  4n2  2nj  lno. For example, 101 is the binary representation of the decimal 5, giving n2  1, nl  0, and no  1 . Using this binary representation, any function of n is now a function of n2, nl and no, with similar forms for functions of k. Thus, X(n) becomes X( n2, nl no). Equation (8.5a) can now be rewritten, using the forward transform with N  8 as the example, as;In this last equation the Zs are essentially weighting factors. To solve this equation, the inner sum is performed, using only the first weight because it is the only weight that is a function of k2. When the next sum is performed, the additional two weights are included. Finally, the last sum uses the remaining three weights. This pattern of solving the sums, and gradually eliminating the k bits and replacing them with n bits can be programmed recursively, requires relatively little scratch storage, and is very efficient in computer time. To a first approximation, the normal discrete Fourier transform requires N2 operations, while the FFT requires only (3N!2)log2N operations. For small data sets (N  1 (0) the resulting computer time or cost difference is insignificant for all practical purposes, because of other overhead costs such as input and output. But for a data set of 1000 points, for example, the FFT computation takes 0.5 of the time that a traditional discrete transform computation would take. There is even some microprocessor hardware available that is specially configured to run FFTs. The bottom line is that the FFT is fast. Most modem computer centers, and some statistical packages for microcomputers,